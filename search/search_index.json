{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Reproducible Research with R AIM OF COURSE: The overarching aim of this course is to provide a comprehensive survey of the field of reproducible research, particularly as it pertains to medical research. The course will provide participants with the practical tools required for implementing reproducibility in their own research work. Several case studies irreproducible and reproducible research will be analyzed in order to appreciate the various aspects of reproducibility. Tutoring is participatory, with hands-on practical sessions that will allow participants to implement the skill-sets learned. This is the tutorial for the computational part of the course. We will be learning how to use the following tools: Git and GitHub, Conda, and finally R markdown.","title":"Home"},{"location":"#welcome-to-reproducible-research-with-r","text":"AIM OF COURSE: The overarching aim of this course is to provide a comprehensive survey of the field of reproducible research, particularly as it pertains to medical research. The course will provide participants with the practical tools required for implementing reproducibility in their own research work. Several case studies irreproducible and reproducible research will be analyzed in order to appreciate the various aspects of reproducibility. Tutoring is participatory, with hands-on practical sessions that will allow participants to implement the skill-sets learned. This is the tutorial for the computational part of the course. We will be learning how to use the following tools: Git and GitHub, Conda, and finally R markdown.","title":"Welcome to Reproducible Research with R"},{"location":"Git/","text":"Introduction to Git Git is a widely used system (both in academia and industry) for version controlling files and collaborating on code. It is used to track changes in (text) files, thereby establishing a history of all edits made to each file, together with short messages about each change and information about who made it. Git is mainly run from the command line, but there are several tools that have implemented a graphical user interface to run git commands. Using version control for tracking your files, and edits to those, is an essential step in making your computational research reproducible. A typical git workflow consists of: making distinct and related edits to one or several files committing those changes (i.e. telling git to add those edits to the history, together with a message about what those changes involve) and pushing the commit to a remote repository (i.e. syncing your local project directory with one in the cloud) There are many benefits of using git in your research project: You are automatically forced into a more organized way of working, which is usually a first step towards reproducibility. If you have made some changes to a file and realize that those were probably not a good idea after all, it is simple to view exactly what the changes were and revert them. If there is more than one person involved in the project, git makes it easy to collaborate by tracking all edits made by each person. It will also handle any potential conflicting edits. Using a cloud-based repository hosting service (the one you push your commits to), like e.g. Github or Bitbucket, adds additional features, such as being able to discuss the project, comment on edits, or report issues. At some point your project will be published. Github or Bitbucket (or similar) are excellent places to publicly distribute your code. Other researchers can then use git to access the code needed for reproducing your results, in exactly the state it was when used for the publication. If needed, you can host private repositories on Github and Bitbucket as well. This may be convenient during an ongoing research project, before it is publicly published. The best way to get an idea about git is simply to start using it. The tutorial below will guide you through the essential steps, with a focus on what is needed for making a project reproducible. There are many additional features of both git and the web-based repository hosting services (like Github and Bitbucket) that are not included here. If you are interested in learning more, the web is filled with information (see some examples below)! Git commands git init: Create an empty Git repository or reinitialize an existing one. Can be used to convert an unversioned project o a git repository or initialize a new empty repository. Until you run this command inside a repository or directory, it\u2019s just a regular folder. Only after you input this does it accept further Git commands. git config: Get and set repository or global options. it is used for configuration of git for the first time. git status: Show the working tree status. See which files are inside it, which changes still need to be committed, and which branch of the repository you\u2019re currently working on. git add: Add file contents to the index. git commit: Git\u2019s most important command. After you make any sort of change, you input this in order to take a \u201csnapshot\u201d of the repository. Usually it goes git commit -m \u201cMessage here.\u201d The -m indicates that the following section of the command should be read as a message. git branch: Working with multiple collaborators and want to make changes on your own? This command will let you build a new branch, or timeline of commits, of changes and file additions that are completely your own. Your title goes after the command. If you wanted a new branch called \u201ccats,\u201d you\u2019d type git branch cats. git checkout: Literally allows you to \u201ccheck out\u201d a repository that you are not currently inside. This is a navigational command that lets you move to the repository you want to check. You can use this command as git checkout master to look at the master branch, or git checkout cats to look at another branch. git merge: When you\u2019re done working on a branch, you can merge your changes back to the master branch, which is visible to all collaborators. git merge cats would take all the changes you made to the \u201ccats\u201d branch and add them to the master. git push: If you\u2019re working on your local computer, and want your commits to be visible online on GitHub as well, you \u201cpush\u201d the changes up to GitHub with this command. git pull: If you\u2019re working on your local computer and want the most up-to-date version of your repository to work with, you \u201cpull\u201d the changes down from GitHub with this command. Get started with Git Install Git Chances are that you already have git installed on your computer. You can check by running e.g. git --version . If you don't have git, install it following the instructions here Configure Git: Now it\u2019s time to go over to the command line. On Windows, that means starting the Git Bash app you just installed, and on OS X, it\u2019s regular old Terminal. It\u2019s time to introduce yourself to Git. Type in the following code: git config --global user.name \"Your Name Here\" Of course, you\u2019ll need to replace \u201cYour Name Here\u201d with your own name in quotations. It can be your legal name, your online handle, anything. Git doesn\u2019t care, it just needs to know to whom to credit commits and future projects. Next, tell it your email and make sure it\u2019s the same email you used when you signed up for a GitHub.com account just a moment ago. Do it like this: git config --global user.email \"your_email@youremail.com\" That\u2019s all you need to do to get started using Git on your computer. However, since you did set up a GitHub.com account, it\u2019s likely you don\u2019t just want to manage your project locally, but also online. If you want you can also set up Git so it doesn\u2019t ask you to log in to your GitHub.com account every time you want to talk to it. For the purposes of this tutorial, it isn\u2019t a big deal since we\u2019ll only be talking to it once. The full tutorial to do this, however, is located on GitHub . Creating Your Online Repository Now that you\u2019re all set up, it\u2019s time to create a place for your project to live. Both Git and GitHub refer to this as a repository, or \u201crepo\u201d for short, a digital directory or storage space where you can access your project, its files, and all the versions of its files that Git saves. Go back to GitHub.com and click the tiny book icon next to your username. Or, go to the new repository page if all the icons look the same. Give your repository a short, memorable name. Go ahead and make it public or private. Skip the initiate a README.md file option. Don\u2019t worry about clicking the checkbox next to \u201cInitialize this repository with a README.\u201d A Readme file is usually a text file that explains a bit about the project. But you can make your own Readme file locally for practice later. Click the green \u201cCreate Repository\u201d button and you\u2019re set. You now have an online space for your project to live in. creat your local repository navigate to the directory where you want to locate your project. on terminal use mkdir to create a directory name it for example myR_project. cd to myR_project type git init Your computer now realizes this directory is Git-ready, and you can start inputting Git commands. Now you\u2019ve got both an online and a local repo for your project to live inside. Now let us check the current status for our project, run git status . It will state that there are untracked files and suggests for you to use git add to include in what will be committed. try to add one of the files. For instance run git add clustering_code then run again git status . You can also add multiple files in one command. For example, run git add Documentation Results/ You might as well add all files in one go! Use git add on the remaining files We are now ready to commit! Run: git commit -m \"adding the first set of files\" modify any file with harmless changes, then run git status . What is the current status? As you can see git already catch the modification you did. Run git diff file_name use the name of the file you did a modification on instead of file_name. . A - means a deleted line, a + means an added line. There are also shown a few lines before and after the changes, to put them in context. Do tow another harmless modification in two different files. Run git status . Now run git diff . If we don't specify a file, it will show all changes made in any file, compared to the previous commit. Do you see your changes?. Now as before git add the two files in one command and then git commit each of them in a separate command. This is a best practics as we want to optimally each commit to be a specified set of changes? To see a history of our changes so far, run: git log You can use git rm file_name to remove a file (this can be seen as a combination of two steps rm file_name then git add file_name ) let us remove clusterimg_result. Run git rm Results/cluster_result . This will add the removing to the staging area. Now you can commit the removal. You can see that directory Results does not exists anymore. Pushing changes to the remote Repository Normally, you sit on your computer an work on a project. you commit changes as you go. At some point (usually when you feel that you have added some new features to the project) you can push these changes to the remote (Online) repository. Since you haven\u2019t connected to the GitHub repo yet, your computer doesn\u2019t even know this exists. So tell your local repository about it: git remote add origin https://github.com/123WebDesign/icecream.git you can now push the changes to the remote repository (usually called the master branch) git push -u origin master If you go to your github project page you can see that all the files are their. Also, they are on lated version. You can check that. Branching with Git branching is an operation that let you work on some features of the project in an isolated manner of the master branch. This effectly means that your work in the new branch will not affect the main project files. You can as ell use branchs to fix a problem that appear in the project. This allow you to work in peace knowing that your stable version is in safe. When you feel that the new feature (you are developing using a new branch) is a good stable state you can merge it with the master branch and it will be part of the project. The diagram above visualizes a repository with two isolated lines of development, one for a little feature, and one for a longer-running feature. By developing them in branches, it\u2019s not only possible to work on both of them in parallel, but it also keeps the main master branch free from questionable code. Note Note that it is more effecint to use branching when you are collaborating with others on a project. Since you may want to develop a new feature while letting otheres keep pushing to the master branch. Note It's important to understand that branches are just pointers to commits. When you create a branch, all Git needs to do is create a new pointer, it doesn\u2019t change the repository in any other way. The repository history remains unchanged. To create a branch you run: git branch branch_name # you can try git branch new_branch # check the branches git branch you see a star beside the branch you are currently inside. Note You may want to work with others on the new branch, this is beyond our course scope. However, you can create a remote branch. Similar to what we before, we need to tell that we add a rempte branch. In the follwoing commands we create and push a copy of the local branch to the remote repo. $ git remote add new_branch-remote-repo `github url` # Add remote repo to local repo config $ git push <new_branch-remote-repo> branch_name~ # pushes the branch_name branch to new-remote-repo you can delete the branch by running git branch -d branch_name However, if the branch hasn\u2019t been merged, the above command will output an error message. To force the delation run git branch -D branch_name The previous commands will delete a local copy of a branch. The branch may still exist in remote repos. To delete a remote branch execute the following. git push origin --delete branch_name checking out branch (switch between branches): The git checkout command lets you navigate between the branches created by git branch. Checking out a branch updates the files in the working directory to match the version stored in that branch, and it tells Git to record all new commits on that branch. Think of it as a way to select which line of development you\u2019re working on. # you can try git checkout new_branch git branch # to varify that you are now moved to the new branch The git checkout command accepts a -b argument that acts as a convenience method which will create the new branch and immediately switch to it. You can work on multiple features in a single repository by switching between them with git checkout. git checkout -b new_branch Merging The git merge command lets you take the independent lines of development created by git branch and integrate them into a single branch. Suppose that after running tests and adding new things you are satisfied with the your new feature that you are develpoing on your new branch. it is now the time to merge with the master branch. You do this with the git merge command (after checking out to the master branch): git checkout master git merge new_branch it is important to distinguish between twoo type of merges that git performe. A fast-forward merge can occur when there is a linear path from the current branch tip to the target branch. Instead of \u201cactually\u201d merging the branches, all Git has to do to integrate the histories is move (i.e., \u201cfast forward\u201d) the current branch tip up to the target branch tip. This effectively combines the histories, since all of the commits reachable from the target branch are now available through the current one. For example, a fast forward merge of some-feature into master would look something like the following: However, a fast-forward merge is not possible if the branches have diverged. When there is not a linear path to the target branch, Git has no choice but to combine them via a 3-way merge. 3-way merges use a dedicated commit to tie together the two histories. The nomenclature comes from the fact that Git uses three commits to generate the merge commit: the two branch tips and their common ancestor. Conflicts If the two branches you're trying to merge both changed the same part of the same file, Git won't be able to figure out which version to use. When such a situation occurs, it stops right before the merge commit so that you can resolve the conflicts manually. We will demonstrate a simple case here. But this can go also with the branches. We will now learn how to manage conflicts. This is important to know, since it will probably happen sooner or later. It can get a bit tricky, but the important thing is not to panic! :) On the github web page, navigate to clustering_code and click on clustering_code.R and click Edit. We can now edit this file directly on the web. This is generally not recommended, but we will do it here to demonstrate a point. Let's just add a comment inside the file. Do that: # adding a comment inside the clustering_code file Click Commit. Add the commit message: \"adding a comment inside the clustering_code file\". Click Commit. Click Commits to the left to see the commit history, and your latest change at the top. Now we have a change in the remote repository that is not yet in our local clone. This could happen for instance if a collaborator of yours committed a change and pushed it to github. Go back to your local terminal. Run git status. Notice that git says: \"Your branch is up-to-date with 'origin/master'.\". This is of course not true, but our local git clone is not yet aware of the remote changes. We will get those changes soon. But first, we will edit clustering_code.R locally as well! (It may be the case that your collaborator thought it was good to use different coding function or different approach, but neither of you communicated that to the other.) Use a text editor and change the the same chenges at the same line. Commit your change (use git status along the way if you want to check what is happening in the different steps): git status git add clustering_code.R git status git commit -m \"adding a comment inside the clustering_code file\" git status Now let's try to push this commit! git push Read the error message. It should be fairly informative of what is going on. In essence it will not allow you to push since there are conflicting changes made to the remote repository. We will now download the changes made to the remote: git fetch Now run git status . Unlike before, our local git clone now is aware of the latest changes pushed to the remote. It will tell you something along the lines: \"Your branch and 'origin/master' have diverged, and have 1 and 1 different commit each, respectively.\". Now, since we ran git fetch our local git has up-to-date information about the status of the remote repository. We can therefore run the following to see what the difference is between the current state of our local clone and the master branch on the remote origin: git diff origin/master Now let's try to integrate the remote changes with our local changes and get up to sync with the remote: git pull Tip Note that you can skip the git fetch command if you want to and run git pull directly. The difference is that fetch will just update git with the latest information of the remote status, whereas pull will try to integrate and sync those changes to your local clone directly. As you have probably noticed, the git pull command resulted in a conflict. Git tells us about this and suggests that we should fix the conflicts and commit that. As always, run git status to get an overview! You will see that you have, so called, unmerged paths and that the conflicting file is clustering_code.R, since both modified the same line in this file. To fix a conflict, open the affected file in a text editor. You will see that it now looks different. Think of these new lines as \"conflict dividers\". The ======= line is the \"center\" of the conflict. All the content between the center and the <<<<<<< HEAD line is content that exists in the local branch origin which the HEAD ref is pointing to. Alternatively all content between the center and >>>>>>> d9b35ef61d2fde56fcbd64aacb10a96098c67cbf (The long sequence of characters is the commit id) is content that is present in our remote branch master. The most direct way to resolve a merge conflict is to edit the conflicted file. Open the clustering_code file in your favorite editor. For our example lets simply remove all the conflict dividers and choose the comment that you want (in this case you may to discuss with your cloaborators about the best way to go around this as usually it is much more than comment). The modified clustering_code.R content. Once the file has been edited use git add clustering_code.R to stage the new merged content. To finalize the merge create a new commit by executing: git commit -m\"merged and resolved the conflict in clustering_code.R\" Git will see that the conflict has been resolved and creates a new merge commit to finalize the merge. Ignoring files Git is aware of all files within the repository. However, it is not uncommon to have files that we don't want git to track. For instance, our analysis might produce several intermediate files and results. We typically don't track such files. Rather, we want to track the actual code and other related files (e.g. configuration files) that produce the intermediate and result files, given the raw input data. To tell git what files to ignore we use a file called .gitignore. Let's create it: touch .gitignore Open the .gitignore file in an editor and add the following lines to it: # Ignore these directories: CsvData/ # Ignore temporary files: .Rhistory .DS_Store Run git status again. Now there is no mention of the results and intermediate directories or the log.tmp file. Notice that we can use wildcards ( * ) to ignore files with a given pattern, e.g. a specific extension. Go ahead and add, commit, and push the .gitignore file. Git with R and Rstudio We assume the following: You\u2019ve registered a free GitHub account. You\u2019ve installed/updated R and RStudio. You\u2019ve installed Git. You\u2019ve introduced yourself to Git. You\u2019ve confirmed that you can push to / pull from GitHub from the command line. Follow the steps: File > New Project > Version Control > Git. In \u201cRepository URL\u201d, paste the URL of your new GitHub repository. It will be something like this https://github.com/your-name/your-repo.git. fill in the project directory name, e.g. myrepo, which coincides with the GitHub repo name. I suggest you check \u201cOpen in new session\u201d, (if you are doing something else in your current session) as that\u2019s what you\u2019ll usually do in real life. Click \u201cCreate Project\u201d From RStudio, modify the any file by adding the any line for instance, \u201cThis is an editing from RStudio\u201d. Save your changes. Commit these changes to your local repo. How? From RStudio: Click the \u201cGit\u201d tab in upper right pane. Check \u201cStaged\u201d box for any file. If you\u2019re not already in the Git pop-up, click \u201cCommit\u201d. Type a message in \u201cCommit message\u201d, such as \u201cCommit from RStudio\u201d. Click \u201cCommit\u201d. Pushing from RStudio: Click the green \u201cPush\u201d button to send your local changes to GitHub. If you are challenged for username and password, provide them (confirm from command line and the gitrepo the changes).","title":"Git"},{"location":"Git/#introduction-to-git","text":"Git is a widely used system (both in academia and industry) for version controlling files and collaborating on code. It is used to track changes in (text) files, thereby establishing a history of all edits made to each file, together with short messages about each change and information about who made it. Git is mainly run from the command line, but there are several tools that have implemented a graphical user interface to run git commands. Using version control for tracking your files, and edits to those, is an essential step in making your computational research reproducible. A typical git workflow consists of: making distinct and related edits to one or several files committing those changes (i.e. telling git to add those edits to the history, together with a message about what those changes involve) and pushing the commit to a remote repository (i.e. syncing your local project directory with one in the cloud) There are many benefits of using git in your research project: You are automatically forced into a more organized way of working, which is usually a first step towards reproducibility. If you have made some changes to a file and realize that those were probably not a good idea after all, it is simple to view exactly what the changes were and revert them. If there is more than one person involved in the project, git makes it easy to collaborate by tracking all edits made by each person. It will also handle any potential conflicting edits. Using a cloud-based repository hosting service (the one you push your commits to), like e.g. Github or Bitbucket, adds additional features, such as being able to discuss the project, comment on edits, or report issues. At some point your project will be published. Github or Bitbucket (or similar) are excellent places to publicly distribute your code. Other researchers can then use git to access the code needed for reproducing your results, in exactly the state it was when used for the publication. If needed, you can host private repositories on Github and Bitbucket as well. This may be convenient during an ongoing research project, before it is publicly published. The best way to get an idea about git is simply to start using it. The tutorial below will guide you through the essential steps, with a focus on what is needed for making a project reproducible. There are many additional features of both git and the web-based repository hosting services (like Github and Bitbucket) that are not included here. If you are interested in learning more, the web is filled with information (see some examples below)!","title":"Introduction to Git"},{"location":"Git/#git-commands","text":"git init: Create an empty Git repository or reinitialize an existing one. Can be used to convert an unversioned project o a git repository or initialize a new empty repository. Until you run this command inside a repository or directory, it\u2019s just a regular folder. Only after you input this does it accept further Git commands. git config: Get and set repository or global options. it is used for configuration of git for the first time. git status: Show the working tree status. See which files are inside it, which changes still need to be committed, and which branch of the repository you\u2019re currently working on. git add: Add file contents to the index. git commit: Git\u2019s most important command. After you make any sort of change, you input this in order to take a \u201csnapshot\u201d of the repository. Usually it goes git commit -m \u201cMessage here.\u201d The -m indicates that the following section of the command should be read as a message. git branch: Working with multiple collaborators and want to make changes on your own? This command will let you build a new branch, or timeline of commits, of changes and file additions that are completely your own. Your title goes after the command. If you wanted a new branch called \u201ccats,\u201d you\u2019d type git branch cats. git checkout: Literally allows you to \u201ccheck out\u201d a repository that you are not currently inside. This is a navigational command that lets you move to the repository you want to check. You can use this command as git checkout master to look at the master branch, or git checkout cats to look at another branch. git merge: When you\u2019re done working on a branch, you can merge your changes back to the master branch, which is visible to all collaborators. git merge cats would take all the changes you made to the \u201ccats\u201d branch and add them to the master. git push: If you\u2019re working on your local computer, and want your commits to be visible online on GitHub as well, you \u201cpush\u201d the changes up to GitHub with this command. git pull: If you\u2019re working on your local computer and want the most up-to-date version of your repository to work with, you \u201cpull\u201d the changes down from GitHub with this command.","title":"Git commands"},{"location":"Git/#get-started-with-git","text":"Install Git Chances are that you already have git installed on your computer. You can check by running e.g. git --version . If you don't have git, install it following the instructions here Configure Git: Now it\u2019s time to go over to the command line. On Windows, that means starting the Git Bash app you just installed, and on OS X, it\u2019s regular old Terminal. It\u2019s time to introduce yourself to Git. Type in the following code: git config --global user.name \"Your Name Here\" Of course, you\u2019ll need to replace \u201cYour Name Here\u201d with your own name in quotations. It can be your legal name, your online handle, anything. Git doesn\u2019t care, it just needs to know to whom to credit commits and future projects. Next, tell it your email and make sure it\u2019s the same email you used when you signed up for a GitHub.com account just a moment ago. Do it like this: git config --global user.email \"your_email@youremail.com\" That\u2019s all you need to do to get started using Git on your computer. However, since you did set up a GitHub.com account, it\u2019s likely you don\u2019t just want to manage your project locally, but also online. If you want you can also set up Git so it doesn\u2019t ask you to log in to your GitHub.com account every time you want to talk to it. For the purposes of this tutorial, it isn\u2019t a big deal since we\u2019ll only be talking to it once. The full tutorial to do this, however, is located on GitHub . Creating Your Online Repository Now that you\u2019re all set up, it\u2019s time to create a place for your project to live. Both Git and GitHub refer to this as a repository, or \u201crepo\u201d for short, a digital directory or storage space where you can access your project, its files, and all the versions of its files that Git saves. Go back to GitHub.com and click the tiny book icon next to your username. Or, go to the new repository page if all the icons look the same. Give your repository a short, memorable name. Go ahead and make it public or private. Skip the initiate a README.md file option. Don\u2019t worry about clicking the checkbox next to \u201cInitialize this repository with a README.\u201d A Readme file is usually a text file that explains a bit about the project. But you can make your own Readme file locally for practice later. Click the green \u201cCreate Repository\u201d button and you\u2019re set. You now have an online space for your project to live in. creat your local repository navigate to the directory where you want to locate your project. on terminal use mkdir to create a directory name it for example myR_project. cd to myR_project type git init Your computer now realizes this directory is Git-ready, and you can start inputting Git commands. Now you\u2019ve got both an online and a local repo for your project to live inside. Now let us check the current status for our project, run git status . It will state that there are untracked files and suggests for you to use git add to include in what will be committed. try to add one of the files. For instance run git add clustering_code then run again git status . You can also add multiple files in one command. For example, run git add Documentation Results/ You might as well add all files in one go! Use git add on the remaining files We are now ready to commit! Run: git commit -m \"adding the first set of files\" modify any file with harmless changes, then run git status . What is the current status? As you can see git already catch the modification you did. Run git diff file_name use the name of the file you did a modification on instead of file_name. . A - means a deleted line, a + means an added line. There are also shown a few lines before and after the changes, to put them in context. Do tow another harmless modification in two different files. Run git status . Now run git diff . If we don't specify a file, it will show all changes made in any file, compared to the previous commit. Do you see your changes?. Now as before git add the two files in one command and then git commit each of them in a separate command. This is a best practics as we want to optimally each commit to be a specified set of changes? To see a history of our changes so far, run: git log You can use git rm file_name to remove a file (this can be seen as a combination of two steps rm file_name then git add file_name ) let us remove clusterimg_result. Run git rm Results/cluster_result . This will add the removing to the staging area. Now you can commit the removal. You can see that directory Results does not exists anymore.","title":"Get started with Git"},{"location":"Git/#pushing-changes-to-the-remote-repository","text":"Normally, you sit on your computer an work on a project. you commit changes as you go. At some point (usually when you feel that you have added some new features to the project) you can push these changes to the remote (Online) repository. Since you haven\u2019t connected to the GitHub repo yet, your computer doesn\u2019t even know this exists. So tell your local repository about it: git remote add origin https://github.com/123WebDesign/icecream.git you can now push the changes to the remote repository (usually called the master branch) git push -u origin master If you go to your github project page you can see that all the files are their. Also, they are on lated version. You can check that.","title":"Pushing changes to the remote Repository"},{"location":"Git/#branching-with-git","text":"branching is an operation that let you work on some features of the project in an isolated manner of the master branch. This effectly means that your work in the new branch will not affect the main project files. You can as ell use branchs to fix a problem that appear in the project. This allow you to work in peace knowing that your stable version is in safe. When you feel that the new feature (you are developing using a new branch) is a good stable state you can merge it with the master branch and it will be part of the project. The diagram above visualizes a repository with two isolated lines of development, one for a little feature, and one for a longer-running feature. By developing them in branches, it\u2019s not only possible to work on both of them in parallel, but it also keeps the main master branch free from questionable code. Note Note that it is more effecint to use branching when you are collaborating with others on a project. Since you may want to develop a new feature while letting otheres keep pushing to the master branch. Note It's important to understand that branches are just pointers to commits. When you create a branch, all Git needs to do is create a new pointer, it doesn\u2019t change the repository in any other way. The repository history remains unchanged. To create a branch you run: git branch branch_name # you can try git branch new_branch # check the branches git branch you see a star beside the branch you are currently inside. Note You may want to work with others on the new branch, this is beyond our course scope. However, you can create a remote branch. Similar to what we before, we need to tell that we add a rempte branch. In the follwoing commands we create and push a copy of the local branch to the remote repo. $ git remote add new_branch-remote-repo `github url` # Add remote repo to local repo config $ git push <new_branch-remote-repo> branch_name~ # pushes the branch_name branch to new-remote-repo you can delete the branch by running git branch -d branch_name However, if the branch hasn\u2019t been merged, the above command will output an error message. To force the delation run git branch -D branch_name The previous commands will delete a local copy of a branch. The branch may still exist in remote repos. To delete a remote branch execute the following. git push origin --delete branch_name checking out branch (switch between branches): The git checkout command lets you navigate between the branches created by git branch. Checking out a branch updates the files in the working directory to match the version stored in that branch, and it tells Git to record all new commits on that branch. Think of it as a way to select which line of development you\u2019re working on. # you can try git checkout new_branch git branch # to varify that you are now moved to the new branch The git checkout command accepts a -b argument that acts as a convenience method which will create the new branch and immediately switch to it. You can work on multiple features in a single repository by switching between them with git checkout. git checkout -b new_branch","title":"Branching with Git"},{"location":"Git/#merging","text":"The git merge command lets you take the independent lines of development created by git branch and integrate them into a single branch. Suppose that after running tests and adding new things you are satisfied with the your new feature that you are develpoing on your new branch. it is now the time to merge with the master branch. You do this with the git merge command (after checking out to the master branch): git checkout master git merge new_branch it is important to distinguish between twoo type of merges that git performe. A fast-forward merge can occur when there is a linear path from the current branch tip to the target branch. Instead of \u201cactually\u201d merging the branches, all Git has to do to integrate the histories is move (i.e., \u201cfast forward\u201d) the current branch tip up to the target branch tip. This effectively combines the histories, since all of the commits reachable from the target branch are now available through the current one. For example, a fast forward merge of some-feature into master would look something like the following: However, a fast-forward merge is not possible if the branches have diverged. When there is not a linear path to the target branch, Git has no choice but to combine them via a 3-way merge. 3-way merges use a dedicated commit to tie together the two histories. The nomenclature comes from the fact that Git uses three commits to generate the merge commit: the two branch tips and their common ancestor.","title":"Merging"},{"location":"Git/#conflicts","text":"If the two branches you're trying to merge both changed the same part of the same file, Git won't be able to figure out which version to use. When such a situation occurs, it stops right before the merge commit so that you can resolve the conflicts manually. We will demonstrate a simple case here. But this can go also with the branches. We will now learn how to manage conflicts. This is important to know, since it will probably happen sooner or later. It can get a bit tricky, but the important thing is not to panic! :) On the github web page, navigate to clustering_code and click on clustering_code.R and click Edit. We can now edit this file directly on the web. This is generally not recommended, but we will do it here to demonstrate a point. Let's just add a comment inside the file. Do that: # adding a comment inside the clustering_code file Click Commit. Add the commit message: \"adding a comment inside the clustering_code file\". Click Commit. Click Commits to the left to see the commit history, and your latest change at the top. Now we have a change in the remote repository that is not yet in our local clone. This could happen for instance if a collaborator of yours committed a change and pushed it to github. Go back to your local terminal. Run git status. Notice that git says: \"Your branch is up-to-date with 'origin/master'.\". This is of course not true, but our local git clone is not yet aware of the remote changes. We will get those changes soon. But first, we will edit clustering_code.R locally as well! (It may be the case that your collaborator thought it was good to use different coding function or different approach, but neither of you communicated that to the other.) Use a text editor and change the the same chenges at the same line. Commit your change (use git status along the way if you want to check what is happening in the different steps): git status git add clustering_code.R git status git commit -m \"adding a comment inside the clustering_code file\" git status Now let's try to push this commit! git push Read the error message. It should be fairly informative of what is going on. In essence it will not allow you to push since there are conflicting changes made to the remote repository. We will now download the changes made to the remote: git fetch Now run git status . Unlike before, our local git clone now is aware of the latest changes pushed to the remote. It will tell you something along the lines: \"Your branch and 'origin/master' have diverged, and have 1 and 1 different commit each, respectively.\". Now, since we ran git fetch our local git has up-to-date information about the status of the remote repository. We can therefore run the following to see what the difference is between the current state of our local clone and the master branch on the remote origin: git diff origin/master Now let's try to integrate the remote changes with our local changes and get up to sync with the remote: git pull Tip Note that you can skip the git fetch command if you want to and run git pull directly. The difference is that fetch will just update git with the latest information of the remote status, whereas pull will try to integrate and sync those changes to your local clone directly. As you have probably noticed, the git pull command resulted in a conflict. Git tells us about this and suggests that we should fix the conflicts and commit that. As always, run git status to get an overview! You will see that you have, so called, unmerged paths and that the conflicting file is clustering_code.R, since both modified the same line in this file. To fix a conflict, open the affected file in a text editor. You will see that it now looks different. Think of these new lines as \"conflict dividers\". The ======= line is the \"center\" of the conflict. All the content between the center and the <<<<<<< HEAD line is content that exists in the local branch origin which the HEAD ref is pointing to. Alternatively all content between the center and >>>>>>> d9b35ef61d2fde56fcbd64aacb10a96098c67cbf (The long sequence of characters is the commit id) is content that is present in our remote branch master. The most direct way to resolve a merge conflict is to edit the conflicted file. Open the clustering_code file in your favorite editor. For our example lets simply remove all the conflict dividers and choose the comment that you want (in this case you may to discuss with your cloaborators about the best way to go around this as usually it is much more than comment). The modified clustering_code.R content. Once the file has been edited use git add clustering_code.R to stage the new merged content. To finalize the merge create a new commit by executing: git commit -m\"merged and resolved the conflict in clustering_code.R\" Git will see that the conflict has been resolved and creates a new merge commit to finalize the merge.","title":"Conflicts"},{"location":"Git/#ignoring-files","text":"Git is aware of all files within the repository. However, it is not uncommon to have files that we don't want git to track. For instance, our analysis might produce several intermediate files and results. We typically don't track such files. Rather, we want to track the actual code and other related files (e.g. configuration files) that produce the intermediate and result files, given the raw input data. To tell git what files to ignore we use a file called .gitignore. Let's create it: touch .gitignore Open the .gitignore file in an editor and add the following lines to it: # Ignore these directories: CsvData/ # Ignore temporary files: .Rhistory .DS_Store Run git status again. Now there is no mention of the results and intermediate directories or the log.tmp file. Notice that we can use wildcards ( * ) to ignore files with a given pattern, e.g. a specific extension. Go ahead and add, commit, and push the .gitignore file.","title":"Ignoring files"},{"location":"Git/#git-with-r-and-rstudio","text":"We assume the following: You\u2019ve registered a free GitHub account. You\u2019ve installed/updated R and RStudio. You\u2019ve installed Git. You\u2019ve introduced yourself to Git. You\u2019ve confirmed that you can push to / pull from GitHub from the command line. Follow the steps: File > New Project > Version Control > Git. In \u201cRepository URL\u201d, paste the URL of your new GitHub repository. It will be something like this https://github.com/your-name/your-repo.git. fill in the project directory name, e.g. myrepo, which coincides with the GitHub repo name. I suggest you check \u201cOpen in new session\u201d, (if you are doing something else in your current session) as that\u2019s what you\u2019ll usually do in real life. Click \u201cCreate Project\u201d From RStudio, modify the any file by adding the any line for instance, \u201cThis is an editing from RStudio\u201d. Save your changes. Commit these changes to your local repo. How? From RStudio: Click the \u201cGit\u201d tab in upper right pane. Check \u201cStaged\u201d box for any file. If you\u2019re not already in the Git pop-up, click \u201cCommit\u201d. Type a message in \u201cCommit message\u201d, such as \u201cCommit from RStudio\u201d. Click \u201cCommit\u201d. Pushing from RStudio: Click the green \u201cPush\u201d button to send your local changes to GitHub. If you are challenged for username and password, provide them (confirm from command line and the gitrepo the changes).","title":"Git with R and Rstudio"},{"location":"Rmarkdown/","text":"Introduction to R Markdown R Markdown provides an authoring framework for data science. You can use a single R Markdown file to both save and execute code generate high quality reports that can be shared with an audience R Markdown documents are fully reproducible and support dozens of static and dynamic output formats. The key tool for R is knitr, which allows you to create a document that is a mixture of text and some chunks of code. When the document is processed by knitr, chunks of R code will be executed, and graphs or other results inserted. This sort of idea has been called \u201cliterate programming\u201d. knitr allows you to mix basically any sort of text with any sort of code, but we recommend that you use R Markdown, which mixes Markdown with R. Markdown is a light-weight mark-up language for creating web pages. Within R Studio, click File \u2192 New File \u2192 R Markdown. You can stick with the default (HTML output), but give it a title. When you run render, R Markdown feeds the .Rmd file to knitr \u29c9, which executes all of the code chunks and creates a new markdown (.md) document which includes the code and it\u2019s output. The markdown file generated by knitr is then processed by pandoc \u29c9 which is responsible for creating the finished format. This may sound complicated, but R Markdown makes it extremely simple by encapsulating all of the above processing into a single render function. Basic components of R Markdown The first chunk is called the header. Here we will later add some instructions. But for now we will give it a simple information. --- title: \"First R markdown document \" author: \"Rani Basna\" date: \"19/11/2019\" output: html_document --- you can change things here. Please do change according to your information. RStudio creates the document with some example text to get you started. Note below that there are chunks like ```{r} summary(cars) ``` These are chunks of R code that will be executed by knitr and replaced by their results. More on this later. Also note the web address that\u2019s put between angle brackets (< >) as well as the double-asterisks in Knit . As you can see, there are essentially three types of components in an R Markdown document: Text (written in R Markdown) Code chunks (written in R, or another supported language). The YAML header For a full detail about the markdown language, you can see the following links GitHub . Besides, here is an image of the typical steps and the most used commands. More on the yaml header and parameters One of the many benefits of working with R Markdown is that you can reproduce analysis at the click of a button. This makes it very easy to update any work and alter any input parameters within the report. Parameterized reports extend this one step further, and allow users to specify one or more parameters to customize the analysis. This is useful if you want to create a report template that can be reused across multiple similar scenarios. Examples may include: Showing results for a specific geographic location. Running a report that covers a specific time period. Running a single analysis multiple times for different assumptions. Controlling the behavior of knitr (e.g., specify if you want the code to be displayed or not). Parameters are specified using the params field within the YAML section. We can specify one or more parameters with each item on a new line. As an example, we will work with out clustering_report.Rmd file: The idea is that we want to control over our report different scinario. Suppose that we want to generate a report with different clustering method. If you are familiar with your function you should know how to do that. For our case we the function fviz_nbclust from the library factoextra can take different clustering methods. Allowed values include kmeans, pam, clara and hcut (for hierarchical clustering). All standard R types that can be parsed by yaml::yaml.load() can be included as parameters, including character, numeric, integer, and logical types. We can also use R objects by including !r before R expressions. let us open the clustering_report inside the markdown_reports folder. edit the file so yaml header looks like this: --- title: \"Cluster-analysis\" output: html_document: default params: cl_method: !r kmeans Rows_num : 5 --- Change the first chunck so it looks like this: ```{r} data(\"USArrests\") # Loading the data set df <- scale(USArrests) # Scaling the data # View the firt 3 rows of the data head(df, params$Rows_num) ``` Also change the second chunck so it lokks like this: ```{r} set.seed(123) # Elbow method fviz_nbclust(df, FUNcluster = params$cl_method, method = \"wss\") + geom_vline(xintercept = 4, linetype = 2)+ labs(subtitle = \"Elbow method\") # Silhouette method fviz_nbclust(df, FUNcluster = params$cl_method, method = \"silhouette\")+ labs(subtitle = \"Silhouette method\") # Gap statistic # nboot = 50 to keep the function speedy. # recommended value: nboot= 500 for your analysis. # Use verbose = FALSE to hide computing progression. fviz_nbclust(df, FUNcluster = params$cl_method, nstart = 25, method = \"gap_stat\", nboot = 200)+ labs(subtitle = \"Gap statistic method\") ``` If you are working with git you may want to commit and push changes from time to time as an exercize. Kinting with parameters There are four ways in which a parameterized report can be knitted: Using the Knit button within RStudio. By running the R command rmarkdown::render() with the params argument from r consol. By running on the terminal command line: R -e 'rmarkdown::render(\"my_file.Rmd\")' Using an interactive user interface to input parameter values. rmarkdown::render(\"MyDocument.Rmd\", params = list( year = 2017, region = \"Asia\", printcode = FALSE, file = \"file2.csv\" )) Now run the fowwlowing code from R consol library(factoextra) rmarkdown::render(\"markdown_reports/clustering_report.Rmd\", params = list(cl_method = hcut, Rows_num = 4))","title":"Rmarkdown"},{"location":"Rmarkdown/#introduction-to-r-markdown","text":"R Markdown provides an authoring framework for data science. You can use a single R Markdown file to both save and execute code generate high quality reports that can be shared with an audience R Markdown documents are fully reproducible and support dozens of static and dynamic output formats. The key tool for R is knitr, which allows you to create a document that is a mixture of text and some chunks of code. When the document is processed by knitr, chunks of R code will be executed, and graphs or other results inserted. This sort of idea has been called \u201cliterate programming\u201d. knitr allows you to mix basically any sort of text with any sort of code, but we recommend that you use R Markdown, which mixes Markdown with R. Markdown is a light-weight mark-up language for creating web pages. Within R Studio, click File \u2192 New File \u2192 R Markdown. You can stick with the default (HTML output), but give it a title. When you run render, R Markdown feeds the .Rmd file to knitr \u29c9, which executes all of the code chunks and creates a new markdown (.md) document which includes the code and it\u2019s output. The markdown file generated by knitr is then processed by pandoc \u29c9 which is responsible for creating the finished format. This may sound complicated, but R Markdown makes it extremely simple by encapsulating all of the above processing into a single render function.","title":"Introduction to R Markdown"},{"location":"Rmarkdown/#basic-components-of-r-markdown","text":"The first chunk is called the header. Here we will later add some instructions. But for now we will give it a simple information. --- title: \"First R markdown document \" author: \"Rani Basna\" date: \"19/11/2019\" output: html_document --- you can change things here. Please do change according to your information. RStudio creates the document with some example text to get you started. Note below that there are chunks like ```{r} summary(cars) ``` These are chunks of R code that will be executed by knitr and replaced by their results. More on this later. Also note the web address that\u2019s put between angle brackets (< >) as well as the double-asterisks in Knit . As you can see, there are essentially three types of components in an R Markdown document: Text (written in R Markdown) Code chunks (written in R, or another supported language). The YAML header For a full detail about the markdown language, you can see the following links GitHub . Besides, here is an image of the typical steps and the most used commands.","title":"Basic components of R Markdown"},{"location":"Rmarkdown/#more-on-the-yaml-header-and-parameters","text":"One of the many benefits of working with R Markdown is that you can reproduce analysis at the click of a button. This makes it very easy to update any work and alter any input parameters within the report. Parameterized reports extend this one step further, and allow users to specify one or more parameters to customize the analysis. This is useful if you want to create a report template that can be reused across multiple similar scenarios. Examples may include: Showing results for a specific geographic location. Running a report that covers a specific time period. Running a single analysis multiple times for different assumptions. Controlling the behavior of knitr (e.g., specify if you want the code to be displayed or not). Parameters are specified using the params field within the YAML section. We can specify one or more parameters with each item on a new line. As an example, we will work with out clustering_report.Rmd file: The idea is that we want to control over our report different scinario. Suppose that we want to generate a report with different clustering method. If you are familiar with your function you should know how to do that. For our case we the function fviz_nbclust from the library factoextra can take different clustering methods. Allowed values include kmeans, pam, clara and hcut (for hierarchical clustering). All standard R types that can be parsed by yaml::yaml.load() can be included as parameters, including character, numeric, integer, and logical types. We can also use R objects by including !r before R expressions. let us open the clustering_report inside the markdown_reports folder. edit the file so yaml header looks like this: --- title: \"Cluster-analysis\" output: html_document: default params: cl_method: !r kmeans Rows_num : 5 --- Change the first chunck so it looks like this: ```{r} data(\"USArrests\") # Loading the data set df <- scale(USArrests) # Scaling the data # View the firt 3 rows of the data head(df, params$Rows_num) ``` Also change the second chunck so it lokks like this: ```{r} set.seed(123) # Elbow method fviz_nbclust(df, FUNcluster = params$cl_method, method = \"wss\") + geom_vline(xintercept = 4, linetype = 2)+ labs(subtitle = \"Elbow method\") # Silhouette method fviz_nbclust(df, FUNcluster = params$cl_method, method = \"silhouette\")+ labs(subtitle = \"Silhouette method\") # Gap statistic # nboot = 50 to keep the function speedy. # recommended value: nboot= 500 for your analysis. # Use verbose = FALSE to hide computing progression. fviz_nbclust(df, FUNcluster = params$cl_method, nstart = 25, method = \"gap_stat\", nboot = 200)+ labs(subtitle = \"Gap statistic method\") ``` If you are working with git you may want to commit and push changes from time to time as an exercize.","title":"More on the yaml header and parameters"},{"location":"Rmarkdown/#kinting-with-parameters","text":"There are four ways in which a parameterized report can be knitted: Using the Knit button within RStudio. By running the R command rmarkdown::render() with the params argument from r consol. By running on the terminal command line: R -e 'rmarkdown::render(\"my_file.Rmd\")' Using an interactive user interface to input parameter values. rmarkdown::render(\"MyDocument.Rmd\", params = list( year = 2017, region = \"Asia\", printcode = FALSE, file = \"file2.csv\" )) Now run the fowwlowing code from R consol library(factoextra) rmarkdown::render(\"markdown_reports/clustering_report.Rmd\", params = list(cl_method = hcut, Rows_num = 4))","title":"Kinting with parameters"},{"location":"conda/","text":"Welcome to reproducible research with R Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Installing Conda package manager *** Install Miniconda3 for 64-bit macOS *** curl https://repo.continuum.io/miniconda/Miniconda3-4.7.12-MacOSX-x86_64.sh -O bash Miniconda3-4.7.12-MacOSX-x86_64.sh rm Miniconda3-4.7.12-MacOSX-x86_64.sh *** Install Miniconda3 for 64-bit Linux *** curl https://repo.continuum.io/miniconda/Miniconda3-4.7.12-Linux-x86_64.sh -O bash Miniconda3-4.7.12-Linux-x86_64.sh rm Miniconda3-4.7.12-Linux-x86_64.sh The installer will ask you questions during the installation: do you accept the license terms? (Yes) do you accept the installation path or do you want to chose a different one? (Probably yes) do you want to run conda init to setup conda on your system? (Yes) Either restart your shell so the settings in ~/.bashrc/~/.bash_profile can take effect, or source ~/.bashrc/~/.bash_profile . Once you have miniconda installed, check the version. conda --version # which version you are running. which conda # Location on your computer. Creating a conda environment for R To use R in an environment, all you need to do is install the r-base package. This will install the latest R version. We can creat R environment with the following command: conda create -n r-env r-base=3.6.1 type R to check the R version. (it should be 3.6.1 (2019-07-05)) Quit R quit() or q(). if you want you can create a new conda environment with all the r-essentials conda packages built from CRAN: (Do not do it now for time sake) conda create -n r_env r-essentials r-base Activate the environment: conda activate r_env to install a specific package: conda install -c r package-name. Conda\u2019s R packages are available from the R channel of Anaconda Cloud, which is included by default in Conda\u2019s default_channels list, so you don\u2019t need to specify the R channel when installing R packages like, say, tidyverse. conda activate r-env (r-env) conda install r-tidyverse=1.2.1 (test this!) List the packages in the environment: conda list Tip You can also search for any R package if you know the name, such as conda search -f r-EXACTNAME . Replace EXACTNAME with the desired CRAN or MRAN R package name. For example, for rbokeh, you would use conda search -f r-rbokeh . Also, Find out what versions of r-factominer are available in the bioconda channel using conda search -c conda-forge r-factominer . remove a package form the environment conda remove r-tidyverse if you want to install an older version of R you can search within conda for all older versions (Do not do it now for time sake) conda search r-base or conda search -c r r create environment conda create -n r_env install the the package with conda conda install -c conda-forge r=3.4.1 . To see all your environments you can run: conda info --envs To remove environment conda env remove -n env_name Some package groups require installation through a different conda channel. Two of the main ones I use are bioconductor Bioconda and conda-forge. Next, we will setup the the default channels (from where packages will be searched for and downloaded if no channel is specified). Type these commands in this exact order: conda config --add channels defaults conda config --add channels bioconda conda config --add channels conda-forge Opening RStudio within the R conda environment To run RStudio in our environment, we can use the single-line conda command(this will install the latest version of RStudio) conda install -c r rstudio Launch RStudio by typing rstudio. The first line in the RStudio console should be the same as when we launched R from the command line directly R version 3.6.1 (2019-07-05). To close RStudio, you can close RStudio itself, or CTRL+C in the terminal from where you launched it. Note note that it is different Danger do not After making a few different environments and installing a bunch of packages, Conda can take up some disk space. You can remove unnecessary files with the command: conda clean -a How to make your project reproducible with Conda environment We have up until now specified which Conda packages to install directly on the command line using the conda create and conda install commands. For working in projects this is not the recommended way. Instead, for increased control and reproducibility, it is better to use a file (in yaml format) specifying packages, versions and channels needed to create the environment for a project. Creat a new environment and installing packages: conda create -n r_env r-essentials r-base conda install -c r rstudio conda install -c conda-forge r-factoextra Go a head and run the following command within your current directory Rscript clustering_code/cluster_code.R CsvData/USArrests.csv Results/clustering_result.csv You can see that we now inside the results folder we have a CSV file that contain the data with the resulting clusters. We will now run the clustering code r file which is already written in the file clustering_code. But in order for us to assure reproducibility of the environment we will build a file that assure such approach. The easiest way to make your work reproducible by others is to include a file in your project\u2019s root directory listing all the packages, along with their version numbers, that are installed in your project\u2019s environment. Conda calls these environment files. you can make the environment.yml file in the following way: (conda-env) % conda env export --file environment.yml # Or -f you can also make this environment file manually by adding the necessary packages one by one. So for example we make the environment.yml file in the following way: channels: - conda-forge - bioconda dependencies: - r-base=3.6.1 - r-essentials=3.6 - r-factominer=1.42 - r-factoextra=1.0.5 Once you created the environment file, you can make a new Conda environment from the yaml file which is identical to the one we have reproducing our environment. (note that here the command is conda env create as opposed to conda create that we used above): conda env create -n r_env2 -f environment.yml Tip Restoring environment to a previous revision: Conda keeps a history of all the changes made to your environment, so you can easily \"roll back\" to a previous version. (this is very import in case you make some error by installing a wrong package or mess up with something instead of removing the environment and state from the begining). To list the history of each change to the current environment: conda list --revisions To restore environment to a previous revision: conda install --rev REVNUM NOTE: Replace REVNUM with the revision number.","title":"Conda"},{"location":"conda/#welcome-to-reproducible-research-with-r","text":"","title":"Welcome to reproducible research with R"},{"location":"conda/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"conda/#installing-conda-package-manager","text":"*** Install Miniconda3 for 64-bit macOS *** curl https://repo.continuum.io/miniconda/Miniconda3-4.7.12-MacOSX-x86_64.sh -O bash Miniconda3-4.7.12-MacOSX-x86_64.sh rm Miniconda3-4.7.12-MacOSX-x86_64.sh *** Install Miniconda3 for 64-bit Linux *** curl https://repo.continuum.io/miniconda/Miniconda3-4.7.12-Linux-x86_64.sh -O bash Miniconda3-4.7.12-Linux-x86_64.sh rm Miniconda3-4.7.12-Linux-x86_64.sh The installer will ask you questions during the installation: do you accept the license terms? (Yes) do you accept the installation path or do you want to chose a different one? (Probably yes) do you want to run conda init to setup conda on your system? (Yes) Either restart your shell so the settings in ~/.bashrc/~/.bash_profile can take effect, or source ~/.bashrc/~/.bash_profile . Once you have miniconda installed, check the version. conda --version # which version you are running. which conda # Location on your computer.","title":"Installing Conda package manager"},{"location":"conda/#creating-a-conda-environment-for-r","text":"To use R in an environment, all you need to do is install the r-base package. This will install the latest R version. We can creat R environment with the following command: conda create -n r-env r-base=3.6.1 type R to check the R version. (it should be 3.6.1 (2019-07-05)) Quit R quit() or q(). if you want you can create a new conda environment with all the r-essentials conda packages built from CRAN: (Do not do it now for time sake) conda create -n r_env r-essentials r-base Activate the environment: conda activate r_env to install a specific package: conda install -c r package-name. Conda\u2019s R packages are available from the R channel of Anaconda Cloud, which is included by default in Conda\u2019s default_channels list, so you don\u2019t need to specify the R channel when installing R packages like, say, tidyverse. conda activate r-env (r-env) conda install r-tidyverse=1.2.1 (test this!) List the packages in the environment: conda list Tip You can also search for any R package if you know the name, such as conda search -f r-EXACTNAME . Replace EXACTNAME with the desired CRAN or MRAN R package name. For example, for rbokeh, you would use conda search -f r-rbokeh . Also, Find out what versions of r-factominer are available in the bioconda channel using conda search -c conda-forge r-factominer . remove a package form the environment conda remove r-tidyverse if you want to install an older version of R you can search within conda for all older versions (Do not do it now for time sake) conda search r-base or conda search -c r r create environment conda create -n r_env install the the package with conda conda install -c conda-forge r=3.4.1 . To see all your environments you can run: conda info --envs To remove environment conda env remove -n env_name Some package groups require installation through a different conda channel. Two of the main ones I use are bioconductor Bioconda and conda-forge. Next, we will setup the the default channels (from where packages will be searched for and downloaded if no channel is specified). Type these commands in this exact order: conda config --add channels defaults conda config --add channels bioconda conda config --add channels conda-forge","title":"Creating a conda environment for R"},{"location":"conda/#opening-rstudio-within-the-r-conda-environment","text":"To run RStudio in our environment, we can use the single-line conda command(this will install the latest version of RStudio) conda install -c r rstudio Launch RStudio by typing rstudio. The first line in the RStudio console should be the same as when we launched R from the command line directly R version 3.6.1 (2019-07-05). To close RStudio, you can close RStudio itself, or CTRL+C in the terminal from where you launched it. Note note that it is different Danger do not After making a few different environments and installing a bunch of packages, Conda can take up some disk space. You can remove unnecessary files with the command: conda clean -a","title":"Opening RStudio within the R conda environment"},{"location":"conda/#how-to-make-your-project-reproducible-with-conda-environment","text":"We have up until now specified which Conda packages to install directly on the command line using the conda create and conda install commands. For working in projects this is not the recommended way. Instead, for increased control and reproducibility, it is better to use a file (in yaml format) specifying packages, versions and channels needed to create the environment for a project. Creat a new environment and installing packages: conda create -n r_env r-essentials r-base conda install -c r rstudio conda install -c conda-forge r-factoextra Go a head and run the following command within your current directory Rscript clustering_code/cluster_code.R CsvData/USArrests.csv Results/clustering_result.csv You can see that we now inside the results folder we have a CSV file that contain the data with the resulting clusters. We will now run the clustering code r file which is already written in the file clustering_code. But in order for us to assure reproducibility of the environment we will build a file that assure such approach. The easiest way to make your work reproducible by others is to include a file in your project\u2019s root directory listing all the packages, along with their version numbers, that are installed in your project\u2019s environment. Conda calls these environment files. you can make the environment.yml file in the following way: (conda-env) % conda env export --file environment.yml # Or -f you can also make this environment file manually by adding the necessary packages one by one. So for example we make the environment.yml file in the following way: channels: - conda-forge - bioconda dependencies: - r-base=3.6.1 - r-essentials=3.6 - r-factominer=1.42 - r-factoextra=1.0.5 Once you created the environment file, you can make a new Conda environment from the yaml file which is identical to the one we have reproducing our environment. (note that here the command is conda env create as opposed to conda create that we used above): conda env create -n r_env2 -f environment.yml Tip Restoring environment to a previous revision: Conda keeps a history of all the changes made to your environment, so you can easily \"roll back\" to a previous version. (this is very import in case you make some error by installing a wrong package or mess up with something instead of removing the environment and state from the begining). To list the history of each change to the current environment: conda list --revisions To restore environment to a previous revision: conda install --rev REVNUM NOTE: Replace REVNUM with the revision number.","title":"How to make your project reproducible with Conda environment"},{"location":"final_word/","text":"Final word: Options for reproducing: Git clone and run workflow. Git clone, activate conda env, and run workflow. Git clone, docker build, and run workflow in container. Docker pull and run workflow in container. Future worth looking tools: Docker Jupeter notebook Gnu make file (or any other make tool such as Snakemake)","title":"Final word"},{"location":"final_word/#final-word","text":"Options for reproducing: Git clone and run workflow. Git clone, activate conda env, and run workflow. Git clone, docker build, and run workflow in container. Docker pull and run workflow in container. Future worth looking tools: Docker Jupeter notebook Gnu make file (or any other make tool such as Snakemake)","title":"Final word:"}]}